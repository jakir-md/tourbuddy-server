generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  USER
  ADMIN
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum TripType {
  SOLO
  BACKPACKING
  LUXURY
  BUSINESS
  FAMILY
  EDUCATIONAL
}

enum ApproveStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id           String  @id @default(uuid())
  name         String
  email        String  @unique
  username     String  @unique
  password     String
  profilePhoto String?

  role       UserRole @default(USER)
  isVerified Boolean  @default(false)

  bio       String?  @db.Text
  age       Int?
  gender    String?
  interests String[]

  subscription Subscription?

  // Relations
  reviewsReceived Review[] @relation("ReviewTarget")
  tripsCreated    Trip[]   @relation("TripCreator")
  reviewsWritten  Review[] @relation("ReviewAuthor")

  // Chat Relations (Module 5)
  sentMessages Message[]

  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  payments            Payment[]
  conversations       Conversation[]
  conversationMembers ConversationMember[]

  requestTarget  JoinRequest[] @relation("TripAdmin")
  requestCreator JoinRequest[] @relation("TripAttendee")

  @@index([email])
}

model Trip {
  id          String   @id @default(uuid())
  name        String
  slug        String   @unique
  destination String
  startDate   DateTime
  endDate     DateTime
  budget      Int
  type        TripType

  approveStatus ApproveStatus @default(PENDING)
  description   String        @db.Text

  locationData Json?
  itinerary    Json?

  activities String[]
  photos     String[]

  userId String
  user   User   @relation("TripCreator", fields: [userId], references: [id], onDelete: Cascade)

  joinRequests JoinRequest[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  conversation Conversation?

  @@index([destination])
  @@index([startDate])
  @@index([budget])
}

model JoinRequest {
  id      String        @id @default(uuid())
  status  RequestStatus @default(PENDING)
  message String? // "Hey! I'd love to join because..."

  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  attendeeId String
  attendee   User   @relation("TripAttendee", fields: [attendeeId], references: [id], onDelete: Cascade)

  tripAdminId String
  admin       User     @relation("TripAdmin", fields: [tripAdminId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Prevent spam: A user can only request a trip once
  @@unique([tripId, attendeeId, tripAdminId])
}

model Conversation {
  id      String @id @default(uuid())
  tripId  String @unique
  name    String @unique
  trip    Trip   @relation(fields: [tripId], references: [id])
  adminId String
  user    User   @relation(fields: [adminId], references: [id])

  messages            Message[]
  conversationMembers ConversationMember[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
}

model ConversationMember {
  id             String       @id @default(uuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
}

model Message {
  id      String @id @default(uuid())
  content String @db.Text

  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  isRead Boolean @default(false) // For "Read Receipts"

  createdAt DateTime @default(now())
}

model Review {
  id      String @id @default(uuid())
  rating  Int // 1-5
  comment String @db.Text

  authorId String
  author   User   @relation("ReviewAuthor", fields: [authorId], references: [id])

  targetId String
  target   User   @relation("ReviewTarget", fields: [targetId], references: [id])

  createdAt DateTime @default(now())
}

model AdminLog {
  id        String   @id @default(uuid())
  action    String // e.g., "BANNED_USER", "VERIFIED_ID"
  adminId   String
  details   Json?
  createdAt DateTime @default(now())
}

model Payment {
  id       String @id @default(uuid())
  amount   Float
  currency String @default("BDT")

  // SSLCommerz Specifics
  transactionId String        @unique // The 'tran_id' you generate
  valId         String? // The 'val_id' SSLCommerz returns on success
  status        PaymentStatus @default(PENDING)

  gatewayResponse Json? // Store full response for debugging (Industry Grade)

  planId String // Track which plan they paid for
  plan   Plan   @relation(fields: [planId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELLED
}
